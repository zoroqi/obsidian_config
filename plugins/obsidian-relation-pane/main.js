/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RelationPanePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// node_modules/svg-tag-names/index.js
var svgTagNames = [
  "a",
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animate",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "animation",
  "audio",
  "canvas",
  "circle",
  "clipPath",
  "color-profile",
  "cursor",
  "defs",
  "desc",
  "discard",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "filter",
  "font",
  "font-face",
  "font-face-format",
  "font-face-name",
  "font-face-src",
  "font-face-uri",
  "foreignObject",
  "g",
  "glyph",
  "glyphRef",
  "handler",
  "hkern",
  "iframe",
  "image",
  "line",
  "linearGradient",
  "listener",
  "marker",
  "mask",
  "metadata",
  "missing-glyph",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "prefetch",
  "radialGradient",
  "rect",
  "script",
  "set",
  "solidColor",
  "stop",
  "style",
  "svg",
  "switch",
  "symbol",
  "tbreak",
  "text",
  "textArea",
  "textPath",
  "title",
  "tref",
  "tspan",
  "unknown",
  "use",
  "video",
  "view",
  "vkern"
];

// node_modules/dom-chef/index.js
var svgTags = new Set(svgTagNames);
svgTags.delete("a");
svgTags.delete("audio");
svgTags.delete("canvas");
svgTags.delete("iframe");
svgTags.delete("script");
svgTags.delete("video");
var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
var isFragment = (type) => type === DocumentFragment;
var setCSSProps = (element, style) => {
  for (const [name, value] of Object.entries(style)) {
    if (name.startsWith("-")) {
      element.style.setProperty(name, value);
    } else if (typeof value === "number" && !IS_NON_DIMENSIONAL.test(name)) {
      element.style[name] = `${value}px`;
    } else {
      element.style[name] = value;
    }
  }
};
var create = (type) => {
  if (typeof type === "string") {
    if (svgTags.has(type)) {
      return document.createElementNS("http://www.w3.org/2000/svg", type);
    }
    return document.createElement(type);
  }
  if (isFragment(type)) {
    return document.createDocumentFragment();
  }
  return type(type.defaultProps);
};
var setAttribute = (element, name, value) => {
  if (value === void 0 || value === null) {
    return;
  }
  if (/^xlink[AHRST]/.test(name)) {
    element.setAttributeNS("http://www.w3.org/1999/xlink", name.replace("xlink", "xlink:").toLowerCase(), value);
  } else {
    element.setAttribute(name, value);
  }
};
var addChildren = (parent, children) => {
  for (const child of children) {
    if (child instanceof Node) {
      parent.appendChild(child);
    } else if (Array.isArray(child)) {
      addChildren(parent, child);
    } else if (typeof child !== "boolean" && typeof child !== "undefined" && child !== null) {
      parent.appendChild(document.createTextNode(child));
    }
  }
};
var booleanishAttributes = /* @__PURE__ */ new Set([
  "contentEditable",
  "draggable",
  "spellCheck",
  "value",
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
]);
var h = (type, attributes, ...children) => {
  var _a;
  const element = create(type);
  addChildren(element, children);
  if (element instanceof DocumentFragment || !attributes) {
    return element;
  }
  for (let [name, value] of Object.entries(attributes)) {
    if (name === "htmlFor") {
      name = "for";
    }
    if (name === "class" || name === "className") {
      const existingClassname = (_a = element.getAttribute("class")) !== null && _a !== void 0 ? _a : "";
      setAttribute(element, "class", (existingClassname + " " + String(value)).trim());
    } else if (name === "style") {
      setCSSProps(element, value);
    } else if (name.startsWith("on")) {
      const eventName = name.slice(2).toLowerCase().replace(/^-/, "");
      element.addEventListener(eventName, value);
    } else if (name === "dangerouslySetInnerHTML" && "__html" in value) {
      element.innerHTML = value.__html;
    } else if (name !== "key" && (booleanishAttributes.has(name) || value !== false)) {
      setAttribute(element, name, value === true ? "" : value);
    }
  }
  return element;
};

// src/RelationView.tsx
var import_obsidian = require("obsidian");
var VIEW_TYPE = "relation-view";
var getBackLinks = (resolvedLinks, filePath, ignorePath) => {
  const backLinks = [];
  for (const src of Object.keys(resolvedLinks)) {
    const links = resolvedLinks[src];
    for (const dest of Object.keys(links)) {
      if (dest === filePath && src !== ignorePath) {
        backLinks.push(src);
      }
    }
  }
  return backLinks;
};
var LinkIcon = () => {
  return /* @__PURE__ */ h("span", {
    className: "tree-item-icon"
  }, /* @__PURE__ */ h("svg", {
    viewBox: "0 0 100 100",
    width: "16",
    height: "16"
  }, /* @__PURE__ */ h("path", {
    fill: "currentColor",
    stroke: "currentColor",
    d: "M73.3,6.7C68,6.7,63,8.7,59.2,12.5l-6.7,6.7c-3.8,3.8-5.9,8.8-5.9,14.1c0,4.2,1.3,8.2,3.7,11.6l-5.5,5.5 c-3.4-2.4-7.4-3.7-11.6-3.7c-5.3,0-10.4,2.1-14.1,5.9l-6.7,6.7C8.7,63,6.7,68,6.7,73.3c0,5.3,2.1,10.4,5.9,14.1s8.8,5.9,14.1,5.9 c5.3,0,10.4-2.1,14.1-5.9l6.7-6.7c3.8-3.8,5.9-8.8,5.9-14.1c0-1.8-0.3-3.6-0.7-5.4l-6,6c-0.2,3.2-1.4,6.3-3.8,8.8l-6.7,6.7 c-5.2,5.2-13.7,5.2-18.9,0c-5.2-5.2-5.2-13.7,0-18.9l6.7-6.7c2.6-2.6,6-3.9,9.4-3.9c2.3,0,4.7,0.7,6.7,1.9L31,64.3 c-0.9,0.8-1.2,2.1-0.9,3.2c0.3,1.2,1.2,2.1,2.4,2.4c1.2,0.3,2.4,0,3.2-0.9L69,35.7c1-1,1.3-2.4,0.7-3.7c-0.5-1.3-1.8-2.1-3.2-2 c-0.9,0-1.7,0.4-2.3,1l-9.1,9.1c-3-5.1-2.4-11.8,2-16.2l6.7-6.7c2.6-2.6,6-3.9,9.4-3.9c3.4,0,6.8,1.3,9.4,3.9 c5.2,5.2,5.2,13.7,0,18.9l-6.7,6.7c-2.4,2.4-5.6,3.7-8.8,3.8l-6,6c1.7,0.5,3.5,0.7,5.4,0.7c5.3,0,10.4-2.1,14.1-5.9l6.7-6.7 c3.8-3.8,5.9-8.8,5.9-14.1c0-5.3-2.1-10.4-5.9-14.1C83.7,8.7,78.7,6.7,73.3,6.7z"
  })));
};
var NewLinkIcon = () => {
  return /* @__PURE__ */ h("span", {
    className: "tree-item-icon"
  }, /* @__PURE__ */ h("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    "stroke-width": "2",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    className: "svg-icon lucide-file-plus"
  }, /* @__PURE__ */ h("path", {
    d: "M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"
  }), /* @__PURE__ */ h("polyline", {
    points: "14 2 14 8 20 8"
  }), /* @__PURE__ */ h("line", {
    x1: "12",
    y1: "18",
    x2: "12",
    y2: "12"
  }), /* @__PURE__ */ h("line", {
    x1: "9",
    y1: "15",
    x2: "15",
    y2: "15"
  })));
};
var extractExt = (name) => {
  return name.replace(/.md$/, "");
};
var RelationView = class extends import_obsidian.ItemView {
  constructor(leaf) {
    super(leaf);
    this.render = this.render.bind(this);
  }
  getViewType() {
    return VIEW_TYPE;
  }
  getDisplayText() {
    return "Relation View";
  }
  getIcon() {
    return "link";
  }
  async onOpen() {
    this.render();
    this.app.workspace.on("file-open", this.render);
    this.app.metadataCache.on("resolved", this.render);
  }
  async onClose() {
    this.app.workspace.off("file-open", this.render);
    this.app.metadataCache.off("resolved", this.render);
  }
  render() {
    const container = this.containerEl.children[1];
    container.empty();
    const file = this.app.workspace.getActiveFile();
    if (!file) {
      console.log("file is not found");
      return;
    }
    const resolvedLinks = this.app.metadataCache.resolvedLinks;
    const links = Object.keys(resolvedLinks[file.path] || {});
    const unresolvedLinks = this.app.metadataCache.unresolvedLinks;
    const newLinks = Object.keys(unresolvedLinks[file.path] || {});
    const backLinks = [];
    for (const src of Object.keys(resolvedLinks)) {
      const links2 = resolvedLinks[src];
      for (const link of Object.keys(links2)) {
        if (link === file.path) {
          backLinks.push(src);
        }
      }
    }
    let frontLinks = Object.keys(resolvedLinks[file.path]) || [];
    let frontUnresolvedLinks = Object.keys(unresolvedLinks[file.path]) || [];
    let twoHopLinks = {};
    for (let page of frontLinks) {
      twoHopLinks[page] = getBackLinks(resolvedLinks, page, file.path);
    }
    for (let page of frontUnresolvedLinks) {
      twoHopLinks[page] = getBackLinks(unresolvedLinks, page, file.path);
    }
    const openLink = (link, newTab = false) => {
      const newLeaf = newTab ? "tab" : void 0;
      this.app.workspace.openLinkText(link, file.path, newLeaf);
    };
    const view = /* @__PURE__ */ h("div", {
      className: "backlink-pane"
    }, /* @__PURE__ */ h("div", {
      className: "tree-item-self"
    }, /* @__PURE__ */ h("div", {
      className: "tree-item-inner"
    }, "Links"), /* @__PURE__ */ h("div", {
      className: "tree-item-flair-counter"
    }, /* @__PURE__ */ h("div", {
      className: "tree-item-flair"
    }, links.length))), /* @__PURE__ */ h("div", {
      className: "search-result-container"
    }, links.map((link) => {
      return /* @__PURE__ */ h("div", {
        className: "tree-item-self search-result-file-title is-clickable",
        onClick: (e) => {
          openLink(link, e.metaKey);
        }
      }, /* @__PURE__ */ h(LinkIcon, null), " ", extractExt(link));
    }), links.length === 0 && /* @__PURE__ */ h("div", {
      className: "search-empty-state"
    }, "No links found.")), /* @__PURE__ */ h("div", {
      className: "tree-item-self"
    }, /* @__PURE__ */ h("div", {
      className: "tree-item-inner"
    }, "Backlinks"), /* @__PURE__ */ h("div", {
      className: "tree-item-flair-counter"
    }, /* @__PURE__ */ h("div", {
      className: "tree-item-flair"
    }, backLinks.length))), /* @__PURE__ */ h("div", {
      className: "search-result-container"
    }, backLinks.map((link) => {
      return /* @__PURE__ */ h("div", {
        className: "tree-item-self search-result-file-title is-clickable",
        onClick: (e) => {
          openLink(link, e.metaKey);
        }
      }, /* @__PURE__ */ h(LinkIcon, null), " ", extractExt(link));
    }), backLinks.length === 0 && /* @__PURE__ */ h("div", {
      className: "search-empty-state"
    }, "No backlinks found.")), Object.keys(twoHopLinks).map((file2) => {
      const links2 = twoHopLinks[file2];
      if (links2.length === 0)
        return;
      const title = file2.replace(/.md$/, "") || "";
      return /* @__PURE__ */ h(DocumentFragment, null, /* @__PURE__ */ h("div", {
        className: "tree-item-self"
      }, /* @__PURE__ */ h("div", {
        className: "tree-item-inner"
      }, title), /* @__PURE__ */ h("div", {
        className: "tree-item-flair-counter"
      }, /* @__PURE__ */ h("div", {
        className: "tree-item-flair"
      }, links2.length))), /* @__PURE__ */ h("div", {
        className: "search-result-container"
      }, links2.map((link) => {
        return /* @__PURE__ */ h("div", {
          className: "tree-item-self search-result-file-title is-clickable",
          onClick: (e) => {
            openLink(link, e.metaKey);
          }
        }, /* @__PURE__ */ h(LinkIcon, null), " ", extractExt(link));
      })));
    }), /* @__PURE__ */ h("div", {
      className: "tree-item-self"
    }, /* @__PURE__ */ h("div", {
      className: "tree-item-inner"
    }, "New Links"), /* @__PURE__ */ h("div", {
      className: "tree-item-flair-counter"
    }, /* @__PURE__ */ h("div", {
      className: "tree-item-flair"
    }, newLinks.length))), /* @__PURE__ */ h("div", {
      className: "search-result-container"
    }, newLinks.map((link) => {
      return /* @__PURE__ */ h("div", {
        className: "tree-item-self search-result-file-title is-clickable",
        onClick: (e) => {
          openLink(link, e.metaKey);
        }
      }, /* @__PURE__ */ h(NewLinkIcon, null), " ", extractExt(link));
    }), newLinks.length === 0 && /* @__PURE__ */ h("div", {
      className: "search-empty-state"
    }, "No new links found.")), false);
    container.appendChild(view);
  }
};

// src/main.ts
var RelationPanePlugin = class extends import_obsidian2.Plugin {
  async onload() {
    this.addCommand({
      id: "open-relation-panel",
      name: "Open relation view",
      checkCallback: (checking) => {
        if (checking) {
          return this.app.workspace.getLeavesOfType(VIEW_TYPE).length === 0;
        }
        this.activateView();
      }
    });
    this.registerView(VIEW_TYPE, (leaf) => {
      return new RelationView(leaf);
    });
    if (this.app.workspace.layoutReady) {
      this.activateView();
    }
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE);
  }
  async activateView() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE);
    const workspaceLeaf = this.app.workspace.getRightLeaf(false);
    await workspaceLeaf.setViewState({
      type: VIEW_TYPE,
      active: true
    });
    this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(VIEW_TYPE)[0]);
  }
};
